---
title: "STA 561 HW2 (Decision Trees)"
author: "Daniel Truver"
date: "1/29/2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##### (1) Classifiers for Basketball Courts  

```{r Perceptron}
perceptron = function(X, y, I){
  iteration = 1
  w = rep(0, ncol(X))
  for (j in 1:I){
    for (i in seq_along(y)){
      if (y[i]*(w %*% X[i,]) <= 0){
        w = w + y[i]*X[i,] # update step
        iteration = iteration + 1
      }
    }
    accuracy = sum((X %*% w) * y > 0)/length(y) # calculate propotion of correctly classified point
    if (accuracy == 1){ 
      break # no need to continue if we have perfect separation
    } 
  }
  return(list("iteration" = iteration, "w" = w, "accuracy" = accuracy))
}
```

(a) Let's run the perceptron because it's fun. 

```{r enteringB-BallData}
X_1 = c(.75, .85, .85, .15,.05,.05,.85)
X_2 = c(.1,.8,.95,.1,.25,.5,.25)
Y = c(-1, -1, 1, -1, 1, 1, -1)
X_b = cbind(X_1, X_2)
```

```{r perceptron}
res = perceptron(X_b, Y, I = 100)
```

The preceptron made `r res$iteration` mistakes before converging with accuracy = `r res$accuracy` (error = `r 1-res$accuracy`). See the decision boundary below. 

```{r perceptronDecisionBound}
suppressMessages(library(ggplot2))
ggplot(data = data.frame(X_1, X_2, Y), aes(x = X_1, y = X_2)) +
  geom_point(aes(pch = factor(Y)), size = 7) +
  scale_shape_manual(values = c("-", "+")) +
  geom_abline(slope = -res$w[["X_1"]]/res$w[["X_2"]], intercept = 0) +
  ggtitle("Result of Perceptron Algorithm",
          subtitle = "Other possible separators featured in color") +
  geom_abline(intercept = 0, slope = 1, color = "red", lty = "dashed") + 
  geom_abline(intercept = 0, slope = 1.05, color = "blue", lty = "dashed") +
  theme_bw() + 
  theme(plot.subtitle = element_text(color = "red"))
```  

(b) Growing the decision tree.

```{r testGrow}
gini.index = function(node){ # function to calculate gini Index
  p = sum(node > 0)/length(node)
  I = 2*p*(1-p)
  return(I)
}
X = X_b
Y = Y
NODE = list(c(1,2,3,4,7))
grow.tree = function(X, Y, current_node = NULL, epsilon = 10^-6){ # split node based on gini index
  X = data.frame(X)
  Y = data.frame(Y = Y)
  data.df = cbind(X,y)
  if (is.null(current_node)){
    current_node = data.df
  }
  # variables to be filled later
  delta.I.record = c()
  leaf1.record = list()
  leaf2.record = list()
  split.record = list()
  c = 1
  for ( i in 1:(ncol(current_node)-1) ){
    # get possible split values, adjust min, max up, down to make inclusive inequalities 
    # run without trouble
    split.sequence = sort(unique(current_node[,i]))
    split.sequence[1] = split.sequence[1] + epsilon
    split.sequence[length(split.sequence)] = split.sequence[length(split.sequence)] - 
      epsilon
    for(x in split.sequence){ # this loop calculates each possible split and reduction in gini index
      split.record = append(split.record, list(c(i, x)))
      node_1 = current_node[which(current_node[,i] <= x),]
      leaf1.record[[c]] = node_1
      I_1 = gini.index(node = node_1$y)
      node_2 = current_node[which(current_node[,i] > x),]
      leaf2.record[[c]] = node_2
      I_2 = gini.index(node = node_2$y)
      delta.I = gini.index(current_node$y) - sum(nrow(node_1)/nrow(current_node)*I_1,
                                                 nrow(node_2)/nrow(current_node)*I_2)
      delta.I.record = c(delta.I.record, delta.I)
      c = c + 1
    }
  }
  optimal = which.max(delta.I.record) # find split with greatest gini reduction
  new.nodes = list(leaf1.record[[optimal]], leaf2.record[[optimal]])
  Split = split.record[[optimal]]
  return(list("opt" = optimal, "leaves" = new.nodes, "split" = Split))
}
```

```{r irrelevantTesting, include=FALSE}
for (current_node in NODES){
  new.nodes = list()
  SPLITS = list()
  delta.I.record = c()
  leaf1.record = list()
  leaf2.record = list()
  split.record = list()
  c = 1
  for (i in 1:ncol(X)){
    split.sequence = sort(unique(X[,i][current_node]))
    split.sequence[1] = split.sequence[1] + epsilon
    split.sequence[length(split.sequence)] = split.sequence[length(split.sequence)] - 
      epsilon
    for(x in split.sequence){
      split.record = append(split.record, list(c(i, x)))
      node_1 = which(X[,i] <= x)
      leaf1.record[[c]] = node_1
      I_1 = gini.index(node = y[node_1])
      node_2 = which(X[,i] > x)
      leaf2.record[[c]] = node_2
      I_2 = gini.index(node = y[node_2])
      delta.I = gini.index(y[current_node]) - sum(length(node_1)/length(current_node)*I_1,
                                               length(node_2)/length(current_node)*I_2)
      delta.I.record = c(delta.I.record, delta.I)
      c = c + 1
    }
  }
  optimal = which.max(delta.I.record)
  new.nodes = append(new.nodes, 
                     list(leaf1.record[[optimal]], leaf2.record[[optimal]]))
  SPLITS = append(SPLITS, split.record[[optimal]])
}
```

The function defined above splits a single node based on the gini index. We implement it below, step by step, until we have grown a full tree.

```{r growingFullTree}
tree_1 = grow.tree(X,Y)
pure_1 = length(unique(tree_1$leaves[[1]]$y)) == 1
pure_2 = length(unique(tree_1$leaves[[2]]$y)) == 1
split_1 = tree_1$split
# we see that the second leaf is not pure, so we attempt to split it again
tree_2 = grow.tree(X, Y, current_node = tree_1$leaves[[2]])
pure_1 = length(unique(tree_2$leaves[[1]]$y)) == 1
pure_2 = length(unique(tree_2$leaves[[2]]$y)) == 1
split_2 = tree_2$split
```

```{r plottingTheTree}
ggplot(data = data.frame(X_1, X_2, Y), aes(x = X_1, y = X_2)) +
  geom_point(aes(pch = factor(Y)), size = 7) +
  scale_shape_manual(values = c("-", "+")) +
  geom_vline(xintercept = res.tree$splits[[2]], lty = "dotted") +
  geom_text(aes(x = res.tree$splits[[2]]+.05, y = 0.7, label = "X_1 <= .05"))
```



